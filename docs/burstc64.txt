? co dalej: zrobić wersję na VIA a może wersję na CPLD?

[20250504] ("działa" == da się zapisać coś do rejestrów CIA)
- force slow clock podczas dostępu do CIA (zgodnie z sugestią z forum), nadal nie działa
- tamta płytka nie działa, zlutuję drugą z minimalnymi poprawkami, może znowu będzie działać
  (wszystko zepsuło się gdy rozciąłem ścieżkę phi2 przy porcie i zastąpiłem przewodem)
- druga zlutowana działa w porządku, to bardzo subtelny efekt!

[20250503]
- żadna z tych opcji nie działa dobrze do zapisu, wszystkie działają dobrze do odczytu (było też phi0 zamiast phi2)
- wersja z tcbm2sd zadziałała raz(!) (MUX zamiast wyjścia RESET, RW zamiast wejścia nRESET)
	CIA = ( cia_range );
	CIA = ( cia_range & ( (RW & !MUX) # (!RW & PHI2 ) ) ); // w tcbm2sd jest Phi0
	CIA = ( cia_range & ( (RW & !MUX) # (!RW & PHI2 & !MUX ) ) );
	CIA = ( cia_range & ( (RW & !MUX) # (!RW ) ) );
	CIA = ( cia_range & ( (RW & !MUX) # PHI2 ) );
- po tych eksperymentach przestała działać (zapis!) też podstawowa wersja
- tcbm2sd:
	drivedataout: adres+<READ> + !pla[10] (odczyt z chipa) MUX==0
	drivedatain : adres+<WRITE>+negedge pla[6](zapis do rejestru) (zapis: opadające phi0)
- forum: https://plus4world.powweb.com/forum/45705#45744
	drivedataout: adres+<READ> + mux==0 lub adres+<READ>+opóźnione phi2
	drivedatain : adres+<WRITE>+ phi2==1
	+'read from exp.bus'(write register) -> BA==1
- to może jednak CPLD?
	- https://github.com/niklasekstrom/cia-verilog/blob/master/cia.v
	- obcięte do 4 rejestrów: $04, $0C, $0D, $0E spokojnie się mieści w XC95144XL-10TQ100C

[20250502]
- próby z innymi CIA - wszystkie fail, nieważne czy Phi2, Phi0 czy zegar CD5420
  zegar TOD nie działa -> prawdopodobnie chodzi o zapis do rejestrów
  frustrujące, przypadkowo jedyny dobry to pierwszy którego spróbowałem
- ten jeden który działa w dodatku działa też na Phi0, tak samo dobrze i to nie jest 6526A, drugi uszkodzony jest z tego samego roku i nie działa
- ROM ma błędy:
  - file not found raportowane jako device not found (gdy burst działa)
  - flaga od adresu ładowania jest odwrotnie (to ,8,1 ładuje w BASIC zamiast loadaddress z pliku)

[20250501]
- SP/CNT są open drain (trzeba czytać datasheet!) i potrzebują 3.3K pullup (tak jak w C128)
- loader działa, ale tylko gdy ekran jest wyłączony (nie lubi wolnego zegara czy zmian prędkości?)
	- skoro zawiesza się w losowych miejscach tzn. gubi potwierdzenie odbioru bajtu
          tzn. CIA rejestruje odczyt i kasuje status w $0D, ale CPU nadal widzi tam 0 zamiast 8
	- można sprawdzić ustawiając IRQ i testować flagę z IRQ zamiast rejestr bezpośrednio
	- no chyba, że CIA faktycznie nie rejestruje odczytu, ale w to wątpię
- TOD sprawdzony, rozwarty używa sprzętowego dzielnika (50.8Hz), zwarty software (49.6Hz)
- na zegarze z CD4520 nie działa dobrze, dostęp do rejestrów nie jest reliable
- na Phi2 działa z wyłączonym ekranem
- potwierdzona logika ROM C1/C2 - C1 dolna połówka, C2 górna - jak tcbm2sd

[20250430]
- logika GAL na /CIA była odwrócona
- ale żeby zrobić prawidłowo trzeba /CIA przenieść na pin 19, więc zamienić /CIA (22) z ROM_A15 (19)
- reset CD4520 połączony (jumper 3-2)
- timing z CD4520 działa tylko gdy kondensator jest rozłączony, a rezystor zastąpiony zworką
- ale Phi2 jako CIACLK działa zdecydowanie lepiej - nie ma losowych błędów odczytu - tak zostawiam
- ROM C1 działa
- ROM C2 chyba działa (bo to BASIC7, który wiesza się z jiffydos, sprawdzić kiedyś na innym)
- na ROM burst bez urządzenia LOAD wiesza się z komunikatem 'SEARCHING' - false positive?

[20250429]
- nie działało, bo sieć +5V nie była połączona z siecią VCC; po połączeniu działa zegar/licznik
- bez CIA pod FD90 widać to samo - losowe liczby
- z CIA komputer się nie uruchamia, czasem zdąży

Zmiany do v1.1 na schemacie i płytce
- sieć +5V połączona z VCC
- /CIA i ROM_A15 zamienione miejscami (19 <-> 22), teraz /CIA na 19
- jumper od CD4520 domyślnie połączony 3-2
- info, że R/C można nie montować
- jumper od zegara z Phi2 albo CD4520 (slow/fast vs slow)
- oznaczyć że GAL to 22V10
- SP i CNT potrzebują pullup 3.3K do VCC
- usunąć połączenie MUX z attiny?
- info o zworce: zwarta=software clock,rozwarta=hw clock

CPLD:
- $04 timer A low
- $0C serial port we/wy
- $0D status - bit 3 (wyszło/weszło)
- $0E kontrola: 2 bity: timer start, port in/out
https://raw.githubusercontent.com/niklasekstrom/cia-verilog/refs/heads/master/cia.v

https://plus4world.powweb.com/pubs/compute_mit/sa_1988-05/compute_mit_sa_1988_5.pdf (str 54)
- tu jest VIA podłączone do r/w, phi2, reset, irq, d0-7, a0-3 i tylko /CS skąd innąd

https://github.com/mist64/cbmsrc/tree/master/KERNAL_TED_05

https://github.com/mist64/cbmsrc/blob/master/BASIC_TED/keydefs.src
	chgkey - programowanie klawisza $B7A7
	doakey - $B7C2 ;enter with len in .a, addr in 'index', & key # (0-7) in 'keynum'=$76
	keyins = $b840
	indin1 (lda (index),y) -> $04b0 index = $22

LDA #0 ; 0-7 (0=F1, 7=F8)
STA $76 ; keynum
LDA #<keydef
STA $22 ; index
LDA #>keydef
STA $23 ; index+1
LDA #keydefend-keydef
JSR $B7C2 ; doakey -> or JSR $FF49

https://github.com/mist64/cbmsrc/blob/master/KERNAL_C128_06/load.src
	C128 burst load
	fast serial detect ($0a1c bit 6)

http://www.ffd2.com/fridge/chacking/c=hacking3.txt - fastload
http://www.ffd2.com/fridge/chacking/c=hacking4.txt - burst lib
http://www.ffd2.com/fridge/chacking/c=hacking19.txt - c64 fastload:

   Both the drive and the computer must detect whether the other side can
   handle fast serial transfers. This is accomplished by sending a byte
   using the synchronous serial port while doing handshaking. The drive
   sends a fast serial byte when the computer sends a secondary address
   (SECOND, which is called by e.g. CHKOUT), the computer can in practice
   send the fast serial byte anytime after the drive is reset and before
   the drive would send fast serial bytes.

tzn. gdybym wysylal komendę przez listen/second (jak w c=hacking 3/4) to powinno się wykryc burst
po second w rejestrze statusu CIA? (nawet nie muszę! ROM tego nie wyczyści, nie jak w C64/128)
Ojala: oldload gdy nazwa zaczyna się od ':', ale DLOAD zawsze dodaje '0:' do nazwy
otwiera kanał #15, po ustawieniu na output już powinno być wiadomo czy to fast, czy slow device


+4 read ram
.C:07d9  08          PHP
.C:07da  78          SEI
.C:07db  8D 3F FF    STA $FF3F
.C:07de  B1 00       LDA ($00),Y
.C:07e0  8D 3E FF    STA $FF3E
.C:07e3  28          PLP
.C:07e4  60          RTS
.C:07e5  18          CLC

trzeba robić toggle CLK out ($01 EOR #$02)
https://ist.uwaterloo.ca/~schepers/MJK/7501.html
P0	SERIAL DATA OUT.
P1	SERIAL CLK output
P2	SERIAL ATN output
P3	Cassette motor.
P4	Cassette read.
P5	Not externally accessible.
P6	SERIAL CLK input
P7	SERIAL DATA input. If jumper J8 is closed, also for Cassette SENSE.

C64:$ee85 - wszystkie ROMy mają clock hi najpierw, potem clocklo, datahi, datalo
TED:$e2b8
LE2B8   LDA   IO
        AND   #$FD
        STA   IO
        RTS    
clkhi
       lda port        	;set clock line high (inverted)
       and #%11111101
       sta port
       rts


https://plus4world.powweb.com/software/Hypaload_1551
- v4.7 do disasemblacji
- ale ta stara (zepsuta) też działa

ROM:
- display welcome message
- install F-key (tools) -> directory browser (tcbm2sd)
- install LOAD vector
	- if 'VERIFY' -> standard load
	- if '$' -> standard load
	- if 1571/81 (burst) -> burst (coś się pojawia na porcie serial przy otwarciu kanału)
	- if tcbm2sd -> ~burst command / fastload tcbm2sd
	- if 1541+parallel -> speeddos
	- if 1541 -> jakiś inny fastloader
	- if 1551 -> hypaload 4.7 (uwaga: nie działa na vice)
- burst detect - c128?
- 'DLOAD' adds '0:' always

TODO:
- decide on I/O address (16 bytes) for CIA, update GAL -> FD90..FD9F CIA, FDA0-AF VIA?

https://www.lemon64.com/forum/viewtopic.php?t=36751

16/+4
PAL: 886724 Hz
NTSC: 894886 Hz



const uint8_t PWM_pin  = 0; // PB0 (OC1A)
const uint8_t MODE_pin = 3; // PB3 – zworka do GND = tryb programowy

bool use_software_pwm;
const uint8_t half_duty_ms = 10;

void setup() {
  pinMode(PWM_pin, OUTPUT);
  pinMode(MODE_pin, INPUT_PULLUP);
  delay(100);

  use_software_pwm = (digitalRead(MODE_pin) == LOW);

  if (!use_software_pwm) {
    // Timer1: źródło zegara = MUX podany na T1 (PB1)
    // Preskaler = 1 (CS10=1), tryb Fast PWM z TOP=ICR1
    TCCR1 = 0;
    GTCCR = 0;
    TCCR1 |= (1 << PWM1A) | (1 << COM1A1);     // non-inverting PWM
    TCCR1 |= (1 << CS10);                      // clock source: ext pin T1, no prescaler
    ICR1  = 17734;
    OCR1A = 8867;
  }
}

void loop() {
  if (use_software_pwm) {
    digitalWrite(PWM_pin, HIGH);
    delay(half_duty_ms);
    digitalWrite(PWM_pin, LOW);
    delay(half_duty_ms);
  }
}











https://a1bert.kapsi.fi/Dev/burst/

Modification to c64
To use burst fastloader with C64 we need to connect the CIA synchronous serial port to the synchronous serial lines of the Commodore peripheral serial bus. Two wires are needed: one to connect the serial bus data line to the syncronous serial port data line and one to connect the serial bus SRQ (the obsolete line for service request, now fast serial clock) to the synchronous serial port clock line. Select the right connections depending on whether you want to use CIA1 or CIA2.

	1570/1,1581				C64

Pin1	SRQ	Fast serial bus clk		CNT1/2	User port 4/6
Pin5	DATA	Data - slow&fast bus		SP1/2	User port 5/7


Top view - old c64, CIA1
User port	Cass port	Serial connector

||||||||||||	||||||		 HHHHH		behind:
||||||||||||	||||||	       .-1 3 5-.
       ||______________________|  2 4  |	  / \
       |	CNT1		   6   |	 // \\
       |_______________________________|	 |||||
		SP1				1 264 5


Top view - old c64, CIA2
User port	Cass port	Serial connector

||||||||||||	||||||		 HHHHH		behind:
||||||||||||	||||||	       .-1 3 5-.
     ||________________________|  2 4  |	  / \
     |	CNT2			   6   |	 // \\
     |_________________________________|	 |||||
		SP2				1 264 5